{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/auth.ts"],"sourcesContent":["import NextAuth, { type NextAuthConfig } from 'next-auth'\r\nimport CredentialsProvider from 'next-auth/providers/credentials'\r\nimport bcrypt from 'bcryptjs'\r\n\r\n// Base configuration that works in Edge Runtime (middleware)\r\nconst baseConfig: NextAuthConfig = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: 'credentials',\r\n      credentials: {\r\n        email: { label: 'Email', type: 'email' },\r\n        password: { label: 'Password', type: 'password' }\r\n      },\r\n      async authorize(credentials) {\r\n        // Import prisma only when needed (in Node.js runtime)\r\n        if (typeof window !== 'undefined') return null\r\n        \r\n        try {\r\n          const { prisma } = await import('./prisma')\r\n          \r\n          if (!credentials?.email || !credentials?.password) {\r\n            return null\r\n          }\r\n\r\n          const user = await prisma.user.findUnique({\r\n            where: {\r\n              email: credentials.email as string\r\n            }\r\n          })\r\n\r\n          if (!user) {\r\n            return null\r\n          }\r\n\r\n          const isPasswordValid = await bcrypt.compare(\r\n            credentials.password as string,\r\n            user.password\r\n          )\r\n\r\n          if (!isPasswordValid) {\r\n            return null\r\n          }\r\n\r\n          return {\r\n            id: user.id,\r\n            email: user.email,\r\n            name: user.name,\r\n          }\r\n        } catch (error) {\r\n          console.error('Auth error:', error)\r\n          return null\r\n        }\r\n      }\r\n    })\r\n  ],\r\n  session: {\r\n    strategy: 'jwt'\r\n  },\r\n  pages: {\r\n    signIn: '/login'\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        return {\r\n          ...token,\r\n          id: user.id\r\n        }\r\n      }\r\n      return token\r\n    },\r\n    async session({ session, token }) {\r\n      return {\r\n        ...session,\r\n        user: {\r\n          ...session.user,\r\n          id: token.id as string\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const { handlers, auth, signIn, signOut } = NextAuth(baseConfig)\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAIA,6DAA6D;AAC7D,MAAM,aAA6B;IACjC,WAAW;QACT,CAAA,GAAA,4JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,sDAAsD;gBACtD,IAAI,OAAO,WAAW,aAAa,OAAO;gBAE1C,IAAI;oBACF,MAAM,EAAE,MAAM,EAAE,GAAG;oBAEnB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;wBACjD,OAAO;oBACT;oBAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBACxC,OAAO;4BACL,OAAO,YAAY,KAAK;wBAC1B;oBACF;oBAEA,IAAI,CAAC,MAAM;wBACT,OAAO;oBACT;oBAEA,MAAM,kBAAkB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;oBAGf,IAAI,CAAC,iBAAiB;wBACpB,OAAO;oBACT;oBAEA,OAAO;wBACL,IAAI,KAAK,EAAE;wBACX,OAAO,KAAK,KAAK;wBACjB,MAAM,KAAK,IAAI;oBACjB;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,eAAe;oBAC7B,OAAO;gBACT;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,OAAO;oBACL,GAAG,KAAK;oBACR,IAAI,KAAK,EAAE;gBACb;YACF;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,OAAO;gBACL,GAAG,OAAO;gBACV,MAAM;oBACJ,GAAG,QAAQ,IAAI;oBACf,IAAI,MAAM,EAAE;gBACd;YACF;QACF;IACF;AACF;AAEO,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,CAAA,GAAA,uJAAA,CAAA,UAAQ,AAAD,EAAE"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/prisma.ts"],"sourcesContent":["import { PrismaClient, Prisma } from '@prisma/client'\r\nimport { withAccelerate } from '@prisma/extension-accelerate'\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: ReturnType<typeof createPrismaClient> | undefined\r\n}\r\n\r\nfunction createPrismaClient() {\r\n  // Determine log levels based on environment variables\r\n  let devLogs: Prisma.LogLevel[] = ['error']; // Default fallback\r\n  \r\n  if (process.env.NODE_ENV === 'development') {\r\n    if (process.env.PRISMA_LOG_LEVEL === 'verbose') {\r\n      devLogs = ['query', 'warn', 'error'];\r\n      console.log('üîç Prisma logging: VERBOSE mode (queries + warnings + errors)');\r\n    } else {\r\n      // 'basic' or any other value = no queries, just warnings and errors\r\n      devLogs = ['warn', 'error'];\r\n      console.log('üéØ Prisma logging: BASIC mode (warnings + errors only)');\r\n    }\r\n  } else {\r\n    console.log('üõ°Ô∏è Prisma logging: PRODUCTION mode (errors only)');\r\n  }\r\n\r\n  return new PrismaClient({\r\n    log: devLogs,\r\n  }).$extends(withAccelerate())\r\n}\r\n\r\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient()\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\r\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,kBAAkB;AAIxB,SAAS;IACP,sDAAsD;IACtD,IAAI,UAA6B;QAAC;KAAQ,EAAE,mBAAmB;IAE/D,wCAA4C;QAC1C,IAAI,QAAQ,GAAG,CAAC,gBAAgB,KAAK,WAAW;YAC9C,UAAU;gBAAC;gBAAS;gBAAQ;aAAQ;YACpC,QAAQ,GAAG,CAAC;QACd,OAAO;YACL,oEAAoE;YACpE,UAAU;gBAAC;gBAAQ;aAAQ;YAC3B,QAAQ,GAAG,CAAC;QACd;IACF;;;IAIA,OAAO,IAAI,uDAAA,CAAA,eAAY,CAAC;QACtB,KAAK;IACP,GAAG,QAAQ,CAAC,CAAA,GAAA,wEAAA,CAAA,iBAAc,AAAD;AAC3B;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/app/api/notes/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { auth } from '@/lib/auth'\r\nimport { prisma } from '@/lib/prisma'\r\n\r\n// Type for note with included relations\r\ntype NoteWithRelations = {\r\n  id: string;\r\n  title: string;\r\n  content: string;\r\n  categoryId: string | null;\r\n  isPinned: boolean;\r\n  order: number;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  userId: string;\r\n  category: { id: string; name: string; userId: string; createdAt: Date } | null;\r\n  noteTags: Array<{\r\n    id: string;\r\n    noteId: string;\r\n    tagId: string;\r\n    createdAt: Date;\r\n    tag: { id: string; name: string; userId: string; createdAt: Date };\r\n  }>;\r\n};\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const session = await auth()\r\n    \r\n    if (!session?.user?.id) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n    }\r\n\r\n    const notes = await prisma.note.findMany({\r\n      where: { userId: session.user.id },\r\n      include: {\r\n        category: true,\r\n        noteTags: {\r\n          include: { tag: true }\r\n        }\r\n      },\r\n      orderBy: [\r\n        { isPinned: 'desc' },\r\n        { order: 'asc' },\r\n        { updatedAt: 'desc' }\r\n      ]\r\n    })\r\n\r\n    // Transform the data to match the expected format\r\n    const transformedNotes = notes.map((note: NoteWithRelations) => ({\r\n      id: note.id,\r\n      title: note.title,\r\n      content: note.content,\r\n      category: note.category?.name || '',\r\n      tags: note.noteTags.map(nt => nt.tag.name),\r\n      createdAt: note.createdAt,\r\n      updatedAt: note.updatedAt,\r\n      isPinned: note.isPinned,\r\n      order: note.order,\r\n      categoryId: note.categoryId,\r\n      userId: note.userId\r\n    }))\r\n\r\n    return NextResponse.json(transformedNotes)\r\n  } catch (error) {\r\n    console.error('Error fetching notes:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await auth()\r\n    \r\n    if (!session?.user?.id) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n    }\r\n\r\n    const { title, content, category, tags, isPinned } = await request.json()\r\n\r\n    if (!title || !content) {\r\n      return NextResponse.json(\r\n        { error: 'Title and content are required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Get the maximum order value for this user's notes\r\n    const maxOrderNote = await prisma.note.findFirst({\r\n      where: { userId: session.user.id },\r\n      orderBy: { order: 'desc' }\r\n    })\r\n    const nextOrder = (maxOrderNote?.order ?? -1) + 1\r\n\r\n    // Create or find category\r\n    let categoryRecord = null\r\n    if (category) {\r\n      categoryRecord = await prisma.category.upsert({\r\n        where: {\r\n          name_userId: {\r\n            name: category,\r\n            userId: session.user.id\r\n          }\r\n        },\r\n        create: {\r\n          name: category,\r\n          userId: session.user.id\r\n        },\r\n        update: {}\r\n      })\r\n    }\r\n\r\n    // Create note\r\n    const note = await prisma.note.create({\r\n      data: {\r\n        title,\r\n        content,\r\n        isPinned: isPinned || false,\r\n        order: nextOrder,\r\n        userId: session.user.id,\r\n        categoryId: categoryRecord?.id\r\n      },\r\n      include: {\r\n        category: true,\r\n        noteTags: {\r\n          include: { tag: true }\r\n        }\r\n      }\r\n    })\r\n\r\n    // Handle tags\r\n    if (tags && Array.isArray(tags)) {\r\n      for (const tagName of tags) {\r\n        // Create or find tag\r\n        const tag = await prisma.tag.upsert({\r\n          where: {\r\n            name_userId: {\r\n              name: tagName,\r\n              userId: session.user.id\r\n            }\r\n          },\r\n          create: {\r\n            name: tagName,\r\n            userId: session.user.id\r\n          },\r\n          update: {}\r\n        })\r\n\r\n        // Create note-tag relationship\r\n        await prisma.noteTag.create({\r\n          data: {\r\n            noteId: note.id,\r\n            tagId: tag.id\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    // Fetch the complete note with relationships\r\n    const completeNote = await prisma.note.findUnique({\r\n      where: { id: note.id },\r\n      include: {\r\n        category: true,\r\n        noteTags: {\r\n          include: { tag: true }\r\n        }\r\n      }\r\n    })\r\n\r\n    // Transform the data\r\n    const transformedNote = {\r\n      id: (completeNote as NoteWithRelations)!.id,\r\n      title: (completeNote as NoteWithRelations)!.title,\r\n      content: (completeNote as NoteWithRelations)!.content,\r\n      category: (completeNote as NoteWithRelations)!.category?.name || '',\r\n      tags: (completeNote as NoteWithRelations)!.noteTags.map(nt => nt.tag.name),\r\n      createdAt: (completeNote as NoteWithRelations)!.createdAt,\r\n      updatedAt: (completeNote as NoteWithRelations)!.updatedAt,\r\n      isPinned: (completeNote as NoteWithRelations)!.isPinned,\r\n      order: (completeNote as NoteWithRelations)!.order,\r\n      categoryId: (completeNote as NoteWithRelations)!.categoryId,\r\n      userId: (completeNote as NoteWithRelations)!.userId\r\n    }\r\n\r\n    return NextResponse.json(transformedNote, { status: 201 })\r\n  } catch (error) {\r\n    console.error('Error creating note:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}